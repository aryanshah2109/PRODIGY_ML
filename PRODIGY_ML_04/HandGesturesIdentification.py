# -*- coding: utf-8 -*-
"""HandGesturesIdentification.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/aryanshah2109/handgesturesidentification-py.8ab7da9b-f097-4261-bf57-a813b4373eb0.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20250630/auto/storage/goog4_request%26X-Goog-Date%3D20250630T143647Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D631587c6ca1fe29b664e1dec78b43656f25027c1ff3d1fd8a79aa814062204ec0538304679d2a47046dcc2b579d39dafbdddc66a3e7e101e8b1228bfdafe8f668844882fd5759016727d7b02ee17d3ab6145d3f0b3162d7d75a53804a2723bd57393fb0d143489b981b28a4ccb2f1542be127f98a85c29f585831e753d56d10ec3435af132fe0d60919e192fc593d64841c6b3a9f3c73e0485c3b2e871fe1d60a2ff96dc74e79b448bff3dc1fbcbfc11a5a5811f67b84b4cd09838465f4ac5fd73ba3621d5c4549806ed7b05da8dbfc47251a5976eb7c8b14f40e63ee485e97f042a15d43ef2a71272e0bed71881ec6df9bf58570d98042635dcceb829fae368
"""

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.
import kagglehub
gti_upm_leapgestrecog_path = kagglehub.dataset_download('gti-upm/leapgestrecog')

print('Data source import complete.')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
import glob
import cv2
import tensorflow
from tensorflow import keras
from keras import Sequential
from keras.layers import Dense,Dropout,BatchNormalization,Conv2D,Flatten,MaxPooling2D
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

# reading data
datadir = '/kaggle/input/leapgestrecog/leapGestRecog'
X = []
y = []
img_size = 64

for label in os.listdir(datadir):
    folder_path = os.path.join(datadir,label)
    # Search recursively for images
    image_paths = glob.glob(folder_path + '/**/*.png', recursive=True)  # Adjust extension if needed

    for img_path in image_paths:
        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)

        if img is None:
            continue

        img = cv2.resize(img, (img_size, img_size))

        X.append(img)
        y.append(int(label))

X = np.array(X)
y = np.array(y)

X= X.reshape(-1,img_size,img_size,1)
X = X/255

X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2,random_state=43)

model = Sequential()

# CNN Layer 1
model.add(Conv2D(32,kernel_size=(3,3),padding='valid',input_shape=(64,64,1),activation='relu'))
model.add(MaxPooling2D(pool_size=(2,2),strides=2,padding='valid'))

# CNN Layer 2
model.add(Conv2D(64,kernel_size=(3,3),padding='valid',activation='relu'))
model.add(MaxPooling2D(pool_size=(2,2),strides=2,padding='valid'))

# Dense layer
model.add(Flatten())
model.add(Dense(128,activation='relu'))
model.add(Dropout(0.1))

# Output layer
model.add(Dense(10,activation='softmax'))

model.compile(loss='sparse_categorical_crossentropy',optimizer='Adam',metrics=['accuracy'])

history = model.fit(X_train,y_train,batch_size=32,epochs=10,validation_data=(X_test,y_test))

plt.plot(history.history['loss'],color='red',label='loss')
plt.plot(history.history['val_loss'],color='blue',label='val_loss')
plt.legend()
plt.show()

plt.plot(history.history['accuracy'],color='red',label='accuracy')
plt.plot(history.history['val_accuracy'],color='blue',label='val_accuracy')
plt.legend()
plt.show()

def predict_input(img):
    prediction = model.predict(img.reshape(1,64,64,1))
    return np.argmax(prediction)

datadir = '/kaggle/input/leapgestrecog/leapGestRecog/00'
labels = os.listdir(datadir)
labels.sort()
labels_names = []
for i in labels:
    labels_names.append(i[3:])

output = predict_input(X_test[3500])

predicted = labels_names[output]
actual = labels_names[y_test[3500]]
print(f'Predicted: {predicted.upper()}, Actual: {actual.upper()}')

